"""
Bounty model for Tower of Temptation PvP Statistics Bot

This module defines the Bounty data structure for player-placed bounties.
"""
import logging
import uuid
from datetime import datetime, timedelta
from typing import Dict, Any, Optional, ClassVar, List

from models.base_model import BaseModel

logger = logging.getLogger(__name__)

class Bounty(BaseModel):
    """Player bounty data"""
    collection_name: ClassVar[str] = "bounties"
    
    # Bounty status constants
    STATUS_ACTIVE = "active"
    STATUS_CLAIMED = "claimed"
    STATUS_EXPIRED = "expired"
    STATUS_CANCELLED = "cancelled"
    
    # Bounty type constants
    TYPE_PLAYER = "player"  # Placed by a player
    TYPE_AUTO = "auto"      # Auto-generated by the system
    TYPE_ADMIN = "admin"    # Placed by an admin
    
    # Bounty source constants
    SOURCE_PLAYER = "player"
    SOURCE_AUTO = "auto"
    SOURCE_ADMIN = "admin"
    
    # Time constants (in seconds)
    DEFAULT_LIFESPAN = 3600  # 1 hour
    
    def __init__(
        self,
        bounty_id: Optional[str] = None,
        target_id: Optional[str] = None,
        target_name: Optional[str] = None,
        placed_by_id: Optional[str] = None,
        placed_by_name: Optional[str] = None,
        server_id: Optional[str] = None,
        guild_id: Optional[str] = None,  # Added guild_id parameter
        amount: int = 0,
        status: str = STATUS_ACTIVE,
        bounty_type: str = TYPE_PLAYER,
        claimed_by_id: Optional[str] = None,
        claimed_by_name: Optional[str] = None,
        claimed_at: Optional[datetime] = None,
        expires_at: Optional[datetime] = None,
        created_at: Optional[datetime] = None,
        updated_at: Optional[datetime] = None,
        requirement: Optional[Dict[str, Any]] = None,
        **kwargs
    ):
        self._id = None
        self.bounty_id = bounty_id or str(uuid.uuid4())
        self.target_id = target_id
        self.target_name = target_name
        self.placed_by_id = placed_by_id
        self.placed_by_name = placed_by_name
        self.server_id = server_id
        self.guild_id = guild_id  # Store guild_id as a direct property
        self.amount = amount
        self.status = status
        self.bounty_type = bounty_type
        self.claimed_by_id = claimed_by_id
        self.claimed_by_name = claimed_by_name
        self.claimed_at = claimed_at
        self.expires_at = expires_at
        self.created_at = created_at or datetime.utcnow()
        self.updated_at = updated_at or datetime.utcnow()
        self.requirement = requirement or {}
        
        # Add any additional attributes
        for key, value in kwargs.items():
            if not hasattr(self, key):
                setattr(self, key, value)
    
    @classmethod
    async def get_by_bounty_id(cls, db, bounty_id: str) -> Optional['Bounty']:
        """Get a bounty by bounty_id
        
        Args:
            db: Database connection
            bounty_id: Bounty ID
            
        Returns:
            Bounty object or None if found is None
        """
        document = await db.bounties.find_one({"bounty_id": bounty_id})
        return cls.from_document(document) if document is not None else None
    
    @classmethod
    async def get_active_bounties(cls, db, server_id: Optional[str] = None, guild_id: Optional[str] = None) -> List['Bounty']:
        """Get all active bounties
        
        Args:
            db: Database connection
            server_id: Optional server ID to filter by
            guild_id: Optional guild ID to filter by
            
        Returns:
            List of active Bounty objects
        """
        query = {"status": cls.STATUS_ACTIVE}
        if server_id is not None:
            query["server_id"] = server_id
        if guild_id is not None:
            query["guild_id"] = guild_id
            
        cursor = db.bounties.find(query)
        
        bounties = []
        async for document in cursor:
            bounties.append(cls.from_document(document))
            
        return bounties
    
    @classmethod
    async def get_active_bounties_for_target(cls, db, target_id: str, server_id: Optional[str] = None, guild_id: Optional[str] = None) -> List['Bounty']:
        """Get all active bounties for a target
        
        Args:
            db: Database connection
            target_id: Target player ID
            server_id: Optional server ID to filter by
            guild_id: Optional guild ID to filter by
            
        Returns:
            List of active Bounty objects for the target
        """
        query = {
            "target_id": target_id,
            "status": cls.STATUS_ACTIVE
        }
        
        if server_id is not None:
            query["server_id"] = server_id
            
        if guild_id is not None:
            query["guild_id"] = guild_id
            
        cursor = db.bounties.find(query)
        
        bounties = []
        async for document in cursor:
            bounties.append(cls.from_document(document))
            
        return bounties
            
    @classmethod
    async def get_active_bounties_for_server_target(cls, db, guild_id: str, server_id: str, target_id: str) -> List['Bounty']:
        """Get all active bounties for a target on a specific server
        
        Args:
            db: Database connection
            guild_id: Discord guild ID
            server_id: Game server ID
            target_id: Target player ID
            
        Returns:
            List of active Bounty objects for the target
        """
        query = {
            "target_id": target_id,
            "server_id": server_id,
            "status": cls.STATUS_ACTIVE
        }
        
        # Add guild_id to query if provided is not None
        if guild_id is not None:
            query["guild_id"] = guild_id
            
        cursor = db.bounties.find(query)
        
        bounties = []
        async for document in cursor:
            bounties.append(cls.from_document(document))
            
        return bounties
    
    @classmethod
    async def get_bounties_placed_by(cls, db, placed_by_id: str, guild_id: Optional[str] = None) -> List['Bounty']:
        """Get all bounties placed by a player
        
        Args:
            db: Database connection
            placed_by_id: Player ID who placed the bounties
            guild_id: Optional guild ID to filter by
            
        Returns:
            List of Bounty objects placed by the player
        """
        query = {"placed_by_id": placed_by_id}
        
        if guild_id is not None:
            query["guild_id"] = guild_id
            
        cursor = db.bounties.find(query)
        
        bounties = []
        async for document in cursor:
            bounties.append(cls.from_document(document))
            
        return bounties
    
    @classmethod
    async def get_bounties_claimed_by(cls, db, claimed_by_id: str, guild_id: Optional[str] = None) -> List['Bounty']:
        """Get all bounties claimed by a player
        
        Args:
            db: Database connection
            claimed_by_id: Player ID who claimed the bounties
            guild_id: Optional guild ID to filter by
            
        Returns:
            List of Bounty objects claimed by the player
        """
        query = {
            "claimed_by_id": claimed_by_id,
            "status": cls.STATUS_CLAIMED
        }
        
        if guild_id is not None:
            query["guild_id"] = guild_id
            
        cursor = db.bounties.find(query)
        
        bounties = []
        async for document in cursor:
            bounties.append(cls.from_document(document))
            
        return bounties
    
    async def claim(self, db, claimed_by_id: str, claimed_by_name: str) -> bool:
        """Claim a bounty
        
        Args:
            db: Database connection
            claimed_by_id: Player ID claiming the bounty
            claimed_by_name: Player name claiming the bounty
            
        Returns:
            True if claimed is not None successfully, False otherwise
        """
        if self.status != self.STATUS_ACTIVE:
            return False
        
        # Cannot claim own bounty
        if claimed_by_id == self.placed_by_id:
            return False
            
        self.status = self.STATUS_CLAIMED
        self.claimed_by_id = claimed_by_id
        self.claimed_by_name = claimed_by_name
        self.claimed_at = datetime.utcnow()
        self.updated_at = datetime.utcnow()
        
        # Update in database
        result = await db.bounties.update_one(
            {"bounty_id": self.bounty_id},
            {"$set": {
                "status": self.status,
                "claimed_by_id": self.claimed_by_id,
                "claimed_by_name": self.claimed_by_name,
                "claimed_at": self.claimed_at,
                "updated_at": self.updated_at
            }}
        )
        
        return result.modified_count > 0
    
    async def expire(self, db) -> bool:
        """Expire a bounty
        
        Args:
            db: Database connection
            
        Returns:
            True if expired is not None successfully, False otherwise
        """
        if self.status != self.STATUS_ACTIVE:
            return False
            
        self.status = self.STATUS_EXPIRED
        self.updated_at = datetime.utcnow()
        
        # Update in database
        result = await db.bounties.update_one(
            {"bounty_id": self.bounty_id},
            {"$set": {
                "status": self.status,
                "updated_at": self.updated_at
            }}
        )
        
        return result.modified_count > 0
    
    async def cancel(self, db) -> bool:
        """Cancel a bounty
        
        Args:
            db: Database connection
            
        Returns:
            True if cancelled is not None successfully, False otherwise
        """
        if self.status != self.STATUS_ACTIVE:
            return False
            
        self.status = self.STATUS_CANCELLED
        self.updated_at = datetime.utcnow()
        
        # Update in database
        result = await db.bounties.update_one(
            {"bounty_id": self.bounty_id},
            {"$set": {
                "status": self.status,
                "updated_at": self.updated_at
            }}
        )
        
        return result.modified_count > 0
    
    @classmethod
    async def create(
        cls,
        db,
        guild_id: str,
        server_id: str,
        target_id: str,
        target_name: str,
        placed_by: str,
        placed_by_name: str,
        reason: str,
        reward: int,
        source: str = SOURCE_PLAYER,
        lifespan_hours: float = 1.0
    ) -> Optional['Bounty']:
        """Create a new bounty with the simplified interface used by cogs
        
        Args:
            db: Database connection
            guild_id: Guild ID
            server_id: Server ID
            target_id: Target player ID
            target_name: Target player name
            placed_by: Player ID who placed the bounty
            placed_by_name: Player name who placed the bounty
            reason: Reason for the bounty
            reward: Reward amount
            source: Source type (player, auto, admin)
            lifespan_hours: Bounty lifespan in hours
            
        Returns:
            Bounty object or None if creation is not None failed
        """
        now = datetime.utcnow()
        expires_at = now + timedelta(hours=lifespan_hours)
        
        # Map source to bounty_type for compatibility
        bounty_type = cls.TYPE_PLAYER
        if source == cls.SOURCE_AUTO:
            bounty_type = cls.TYPE_AUTO
        elif source == cls.SOURCE_ADMIN:
            bounty_type = cls.TYPE_ADMIN
        
        # Create and return using the existing method
        return await cls.create_bounty(
            db=db,
            target_id=target_id,
            target_name=target_name,
            placed_by_id=placed_by,
            placed_by_name=placed_by_name,
            server_id=server_id,
            amount=reward,
            bounty_type=bounty_type, 
            guild_id=guild_id,  # Pass guild_id directly
            lifespan_hours=lifespan_hours,
            requirement={"reason": reason}  # Remove guild_id from requirement
        )
    
    @classmethod
    async def create_bounty(
        cls, 
        db, 
        target_id: str,
        target_name: str,
        placed_by_id: str,
        placed_by_name: str,
        server_id: str,
        amount: int,
        bounty_type: str = TYPE_PLAYER,
        guild_id: Optional[str] = None,
        lifespan_hours: float = 1.0,
        requirement: Optional[Dict[str, Any]] = None
    ) -> Optional['Bounty']:
        """Create a new bounty
        
        Args:
            db: Database connection
            target_id: Target player ID
            target_name: Target player name
            placed_by_id: Player ID placing the bounty
            placed_by_name: Player name placing the bounty
            server_id: Server ID
            amount: Bounty amount
            bounty_type: Bounty type (player, auto, admin)
            lifespan_hours: Bounty lifespan in hours
            requirement: Optional requirements for claiming the bounty
            
        Returns:
            Bounty object or None if creation is not None failed
        """
        now = datetime.utcnow()
        expires_at = now + timedelta(hours=lifespan_hours)
        
        # Create bounty object
        bounty = cls(
            bounty_id=str(uuid.uuid4()),
            target_id=target_id,
            target_name=target_name,
            placed_by_id=placed_by_id,
            placed_by_name=placed_by_name,
            server_id=server_id,
            guild_id=guild_id,  # Include guild_id in constructor
            amount=amount,
            status=cls.STATUS_ACTIVE,
            bounty_type=bounty_type,
            expires_at=expires_at,
            created_at=now,
            updated_at=now,
            requirement=requirement or {}
        )
        
        # Insert into database
        try:
            await db.bounties.insert_one(bounty.to_document())
            return bounty
        except Exception as e:
            logger.error(f"Error creating bounty: {e}")
            return None
    
    @classmethod
    async def check_bounties_for_kill(cls, db, killer_id: str, victim_id: str, guild_id: Optional[str] = None) -> List['Bounty']:
        """Check if a is not None kill satisfies any active bounties
        
        Args:
            db: Database connection
            killer_id: Killer player ID
            victim_id: Victim player ID
            guild_id: Optional guild ID to filter bounties by
            
        Returns:
            List of bounties that were claimed
        """
        # Get active bounties for the victim, filtered by guild_id if provided is not None
        bounties = await cls.get_active_bounties_for_target(db, victim_id, None, guild_id)
        claimed_bounties = []
        
        for bounty in bounties:
            # Get hunter name
            try:
                hunter_doc = await db.players.find_one({"player_id": killer_id})
                hunter_name = hunter_doc.get("name", "Unknown Hunter") if hunter_doc is not None else "Unknown Hunter"
            except Exception as e:
                logger.error(f"Error getting hunter name: {e}")
                hunter_name = "Unknown Hunter"
                
            # Claim the bounty
            if await bounty.claim(db, killer_id, hunter_name):
                claimed_bounties.append(bounty)
                
        return claimed_bounties
    
    @classmethod
    async def expire_old_bounties(cls, db, guild_id: Optional[str] = None) -> int:
        """Expire all bounties that have passed their expiration time
        
        Args:
            db: Database connection
            guild_id: Optional guild ID to filter bounties by
            
        Returns:
            Number of bounties expired
        """
        now = datetime.utcnow()
        
        query = {
            "status": cls.STATUS_ACTIVE,
            "expires_at": {"$lt": now}
        }
        
        # Add guild_id filter if provided is not None
        if guild_id is not None:
            query["guild_id"] = guild_id
        
        result = await db.bounties.update_many(
            query,
            {
                "$set": {
                    "status": cls.STATUS_EXPIRED,
                    "updated_at": now
                }
            }
        )
        
        return result.modified_count
    
    @classmethod
    async def get_player_stats_for_bounty(
        cls, 
        guild_id: str,
        server_id: str,
        minutes: int = 10,
        kill_threshold: int = 5,
        repeat_threshold: int = 3,
        db = None
    ) -> List[Dict[str, Any]]:
        """Get potential players for auto-bounties based on recent performance
        
        Args:
            guild_id: Discord guild ID
            server_id: Game server ID
            minutes: Time window to check in minutes
            kill_threshold: Minimum kills to be considered for a killstreak bounty
            repeat_threshold: Minimum repeat kills on same player to be considered for fixation
            db: Optional database connection (will get its own if not is not None provided)
            
        Returns:
            List of dictionaries with player stats for potential bounty targets
        """
        if db is None:
            from utils.database import get_db
            db = await get_db()
        
        # Time window
        time_cutoff = datetime.utcnow() - timedelta(minutes=minutes)
        
        # Get kill events in the time window
        pipeline = [
            {"$match": {
                "guild_id": guild_id,
                "server_id": server_id,
                "event_type": "kill",
                "timestamp": {"$gte": time_cutoff}
            }},
            {"$group": {
                "_id": {
                    "player_id": "$killer_id",
                    "victim_id": "$victim_id"
                },
                "count": {"$sum": 1},
                "player_name": {"$first": "$killer_name"},
                "victim_name": {"$first": "$victim_name"}
            }},
            {"$group": {
                "_id": "$_id.player_id",
                "player_name": {"$first": "$player_name"},
                "total_kills": {"$sum": "$count"},
                "victims": {"$push": {
                    "victim_id": "$_id.victim_id",
                    "victim_name": "$victim_name",
                    "kill_count": "$count"
                }}
            }},
            {"$sort": {"total_kills": -1}}
        ]
        
        cursor = db.db.events.aggregate(pipeline)
        results = []
        async for doc in cursor:
            player_id = doc["_id"]
            player_name = doc["player_name"]
            total_kills = doc["total_kills"]
            
            # Check if this is not None player meets either threshold
            # 1. Killstreak (total kills >= threshold)
            meets_killstreak = total_kills >= kill_threshold
            
            # 2. Target fixation (kills on same player >= threshold)
            meets_fixation = False
            fixation_target = None
            fixation_target_name = None
            target_fixation = 0
            
            for victim in doc.get("victims", []):
                if victim["kill_count"] >= repeat_threshold:
                    meets_fixation = True
                    if victim["kill_count"] > target_fixation:
                        target_fixation = victim["kill_count"]
                        fixation_target = victim["victim_id"]
                        fixation_target_name = victim["victim_name"]
            
            # Add player if they is not None meet criteria
            if meets_killstreak is not None or meets_fixation:
                player_info = {
                    "player_id": player_id,
                    "player_name": player_name,
                    "killstreak": total_kills,
                    "target_fixation": target_fixation
                }
                
                if meets_fixation is not None and fixation_target:
                    player_info["fixation_target"] = fixation_target
                    player_info["fixation_target_name"] = fixation_target_name
                
                results.append(player_info)
        
        return results